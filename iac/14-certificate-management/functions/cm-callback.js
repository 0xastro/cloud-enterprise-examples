const {promisify} = require('bluebird');
let request = promisify(require('request'));
request = request.defaults({json: true});
const jwtVerify = promisify(require('jsonwebtoken').verify);
const jwtDecode = require('jsonwebtoken').decode;

/**
 * Get the public key used to verify that the notification payload is generated by your Certificate Manager instance.
 * @param body Object
 * @param certificateManagerApiUrl
 * @returns {Promise<publicKey>}
 */
const getPublicKey = async (body, certificateManagerApiUrl) => {
    console.log(`Get public key for instance ${body.instance_crn}`);
    const keysOptions = {
        method: 'GET',
        url: `${certificateManagerApiUrl}/api/v1/instances/${encodeURIComponent(body.instance_crn)}/notifications/publicKey?keyFormat=pem`,
        headers: {'cache-control': 'no-cache'}
    };
    let response;
    try {
        response = await request(keysOptions);
    }
    catch (err) {
        console.log(`Couldn't get the public key for instance ${body.instance_crn}. Reason is: ${getErrorString(err)}`);
        throw new Error(`Couldn't get the public key for instance ${body.instance_crn}`);
    }
    if (response.statusCode !== 200) {
        console.error(`Couldn't get the public key for instance ${body.instance_crn} . Reason is: status code ${response.statusCode} and body ${JSON.stringify(response.body)}`);
        throw new Error(`Couldn't get the public key for instance ${body.instance_crn}`);
    }
    return response.body.publicKey;
};


/**
 *
 * main() will be run when you invoke this action
 *
 * @param params Cloud Functions actions accept a single parameter, which must be a JSON object.
 *
 * @return The output of this action, which must be a JSON object.
 *
 */
const main = async (params)=> {
    console.log("Cloud function invoked.");
    try {

        const body = jwtDecode(params.data);

        // Validate that the notification was sent from a Certificate Manager instance that has allowed access
        if (!params.allowedCertificateManagerCRNs || !params.allowedCertificateManagerCRNs[body.instance_crn]) {
            console.error(`Certificate Manager instance ${body.instance_crn} is not allowed to invoke this action`);
            return Promise.reject({
                statusCode: 403,
                headers: {'Content-Type': 'application/json'},
                body: {message: 'Unauthorized'},
            });
        }
        const certificateManagerApiUrl = `https://${params.cmRegion}.certificate-manager.cloud.ibm.com`;
        const publicKey = await getPublicKey(body, certificateManagerApiUrl);
        const decodedNotification = await jwtVerify(params.data, publicKey);

        // console.log(`Notification message body: ${JSON.stringify(decodedNotification)}`);
        switch (decodedNotification.event_type) {
            // Handle other certificate manager event types.
            // ...

            // Handling domain validation event types.
            case "cert_domain_validation_required":
                console.log(`Validation requested for domain: ${body.domain}`);
                console.log(`TXT record name: ${body.challenge.txt_record_name}, TXT value: ${body.challenge.txt_record_val}`);
                break;
            case "cert_domain_validation_completed":
                console.log('Validation completed - ok to remove TXT record')
                break;
        }
    }
    catch (err) {
        console.log(`Action failed. Reason: ${getErrorString(err)}`);
        return Promise.reject({
            statusCode: err.statusCode ? err.statusCode : 500,
            headers: {'Content-Type': 'application/json'},
            body: {message: err.message ? err.message : 'Error processing your request'},
        });
    }
    return {
        statusCode: 200,
        headers: {'Content-Type': 'application/json'},
        body: {}
    };
};

const getErrorString = (error) => {
    if (error)
        return (typeof error.message === 'string') ? error.message : JSON.stringify(error);
    else
        return 'Error undefined';
};